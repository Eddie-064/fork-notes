
## 为什么选择 nix

nixpkg 相比其他包管理器，拥有完全不同的设计哲学，你可以将它理解成用 git 的方式管理软件包，git 最大的好处是啥？那显然就是多版本管理，可以随时回退到任一历史环境。

nix 的优点：

- 可回滚：可以随时回滚到任一历史环境，所以也被认为是最稳定的包管理方式。
- 声明式配置，可复现，甚至可以在其他机器上还原整个系统环境
  - nix flake 通过函数式语言的方式描述了软件包的依赖关系，并通过 flake.lock （借鉴了 cargo/npm）记录了所有依赖项的数据源与 hash 值，这使得 nix 可以在不同机器上生成完全一致的环境。
  - 这与 docker/vargrant 有点类似，不过 docker/vargrant 的目标环境都是隔离的容器或虚拟机，nix 比它们更通用，可以用于管理任何物理机、虚拟机、容器的环境。
- 没有依赖冲突问题：因为 nix 中每个软件包都拥有唯一的 hash，其安装路径中也会包含这个 hash 值，因此可以多版本共存。任何其他依赖了某个特定包的 nix 包，都会在其配置文件中声明依赖的包的 hash，这样它只能看到这个 hash 对应的包，就不存在冲突。

nix 的缺点：

- 非常吃硬盘空间：为了保证系统可以随时回退，nix 默认总是保留所有历史环境，这非常吃硬盘空间。虽然可以定期使用 `nix-collect-garbage` 来手动清理旧的历史环境，也还是建议配置个更大的硬盘...
- 学习成本高：如果你希望系统完全可复现，并且避免各种不当使用导致的坑，那就需要学习了解 nix 的整个设计，包括 nix 函数语言。而其他发行版可以直接 `apt install`，因此想要用好 nix，学习成本还是比较高的。
- 包数量比较少：官方宣称 nixpkgs 是有 [80000+](https://search.nixos.org/packages) 个软件包，但是实际体验下来还是比不上 arch linux，毕竟 AUR 生态是真的丰富。
  - 如果手动安装了 nixpkgs 中没有的包，“可回滚“这点或许仍然能达成，但显然就享受不到”可复现“这个功能了。除非你自己把这个包移植到 nix。
  - 在使用 NixOS 作为主力机系统时，自己打包几乎是不可避免的，因为你总会遇到些偏门的包 nixpkgs 里面没有，社区也没人搞过，除了自己写 derivation 打包别无它法。

因为 nix 声明式、可复现的特性，nix 不仅可用于管理桌面电脑的环境，也有很多人用它管理开发编译环境、云上虚拟机、容器镜像构建，并且 Nix 官方也推出了基于 Nix 的运维工具 NixOps。



