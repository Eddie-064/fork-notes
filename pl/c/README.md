# C 语言

## 多文件项目

1. 将项目拆分成多个 `.c` 及 `.h` 文件，在 `.h` 中声明所有公共的方法、常量。
   1. `#include "filename"` 从当前文件夹开始寻找该头文件，如果本地找不到，再去系统的 lib 中找。
   2. `#include <filename>` 仅从系统的 lib 中寻找该头文件！
2. `static` 修饰的全局变量或者函数：仅在当前 `.c` 文件中可见，所有 `.c` 中的全局变量或者函数，都应该
   使用 `static` 修饰。
   1. `static` 也可用于局部变量，但是这种用法感觉不太常见。它为 function 提供了一个私有的、永久性的
      存储，在函数的多次执行中，该变量可以持久地存在并被使用。
3. `auto` 关键字声明自动变量，所有的局部变量默认都是自动变量。
   1. `auto` 的含义即为，它们会在程序运行期间被自动地创建、自动地销毁。
4. `register` 寄存器变量
   1. 此声明用于告知编译器该变量将被频繁使用，建议把它保存在 CPU 寄存器中。但是编译器有权忽略该建
      议。

## 常用函数

1. 字符处理
   1. `strlen`
   2. `atoi`: ascii to int
   3. `<ctype.h>`: 提供了 `islower` `isdigit` 等几个字符判断函数，以及 `tolower` `toupper` 两个大小
      写转换函数。
   4. 非标准库字符处理函数（windows `<conio.h>`, Linux `<ncurses.h>` 需要安装 ncurses-dev）
1. 数学 `<math.h>`
   1. `sqrt`

## 易错知识点摘要

1. 文件结束符 EOF 在 `<stdio.h>` 中定义，是一个不在 ASCII 定义中的整数，通常使用 `-1` 来表示它。
   1. 这导致必须使用 `int` 来存储一个字符，否则 EOF 这个特殊值会发生溢出！
2. `getchar()` 从 `stdin` 中读取一个字符，但它是一个行缓冲函数，如果读到文件末尾，在遇到 `\n` 或者
   EOF 前会一直阻塞。
   1. `putchar(c)` 则相反，将 c 放入 `stdout` 中。
3. 函数的传参，所有的参数都是传值，将外部变量的值 copy 给形参。
   1. 因此要特别注意传指针的情况，防止误修改。
4. 溢出：C 语言最需要警惕的问题之一，包括输入溢出、数字溢出。
5. 常量后缀。使用它可避免未知的隐式类型转换。
   1. `1L`: long 类型
   2. `1u`: unsigned int
   3. `1ul` 或者 `1UL`: unsigned long
   4. 无后缀：double 双精度
   5. `1.0f` 或者 `1.0F`: float 单精度
   6. `1.0l` 或者 `1.0L`: long double 长双精度
6. 常量前缀。用于表示不同的进制
   1. `0b11` 或者 `0B11`: 二进制数 11
   2. `017`: 8 进制数 17
      1. 因为前缀 0 容易引起歧义，Python 强制使用前缀 `0o`，即使用 `0o7` 来表示 8 进制。
   3. `0x17` 或者 `0X17`: 16 进制数 17
7. 字符与字符串字面量
   1. `'x'` 表示字符 x，类型为 `char`
   2. `"x"` 表示字符串 `['x', '\0']`，类型为 `char []`
8. `const` 限定符与指针共同使用时要注意，`const` 仅限定指针本身不可变！指针指向的变量是不受限制的。
9. 强制自动类型转换的规则：把较窄的操作数转换为较宽的操作数（提升精度低的操作数）
10. 坑：char 的符号之争。一般 signed 与 unsigned 的 char 使用上没啥区别，但是在类型转换时会涉及位拓
    展问题。
11. 无符号数：它很省空间，但是也非常危险，很容易搞出预期外的问题！
    1. 应该仅在这两种场景下使用无符号数：需要执行按位运算时、需要进行不寻常的算术操作时。
12. 对于 `n++++` 这类问题的讨论没有什么意义，C 语言并未规定它的结果，它的执行效果因环境而异，属于未
    定义行为！
    1. 绝对不能随意些这类代码！

**C 语言中的隐式类型转换导致了太多的坑！转换结果往往出人意料！一定要尽量避免隐式类型转换**!

## 结构体

结构体的定义方式：

```c
struct complex_struct {
   double x, y;
   int z;
};
```

结构体的初始化方式：

```c
// 使用变量或者常量进行初始化
// C99 开始允许使用变量进行结构体初始化
struct complex_struct z1 = {x, 4.0, 1}; // z1.x = x, z1.y = 4.0, z1.z = 1;

// 部分初始化
struct complex_struct z1 = {1.0}; // z1.x = 1.0, z1.y = 0.0, z1.z = 0;

// 全部赋值为 0
struct complex_struct z1 = {0}; // z1.x = 0.0, z1.y = 0.0, z1.z = 0;

// C99 新特性定制初始化 Designated Initializers
// 适用于大部分值都需要设为 0，仅少部分参数需要单独指定的场景
struct complex_struct z1 = {
   .y = 1.0,
   .z = 1,   // 这里允许末尾添加逗号
};
```

初始化完成后，可以通过 `z1.x` 这样的语法去使用结构体中的变量。

嵌套结构体的初始化：

```c
// 嵌套结构体
struct segment {
   struct complexity_struct start;
   struct complexity_struct end;
};

// 嵌套地初始化
struct segment s = {
   {1.0, 2.0},
   {3.0, 4.0},
};

// 平坦初始化（Flat）
struct segment s = {
   1.0, 2.0,
   3.0, 4.0,
};

// 实际上也可同时使用嵌套初始化跟平坦初始化，但是可读性会很差，是很糟糕的用法。
```

结构体的成员访问语法：

```c
// 使用 a.b 来访问结构体 a 的成员 b
a.b += 1;

// 对于结构体指针 p，可使用 -> 来直接访问其成员
p->b += 1;  // 等同于 (*p).b += 1;
```

## 数组

数组初始化：

```c
int count[4] = {3, 2, };  // 部分初始化 [3, 2, 0, 0]

int count[4] = {[2]=3};  // C99 member-wise initialization

int count[] = {3,2,1};  // 也可不指定长度，由编译器自动根据初始化表达式来决定数组长度。

// 多维数组的嵌套初始化
int count[][3] {{0}, {0}, {0}}
```

数组索引：索引从 0 开始，而且编译器不检测指针越界！所以错误的索引会导致运行时错误！

```c
count[3] // 正常

count[-1]  // 使用负数也可正常编译，但是运行期会报错指针越界！

count[100] // 指针越界
```

C99 变长数组（VLA，variable length array），只能在局部变量上使用：

```c
int test(int size) {
   int data[size] = {0};  // 使用变量作为数组的长度，即在运行期确认数组长度。
}
```

变长数组跟 `alloc`/`afree` 实质上就是**在栈空间上进行动态的内存分配**，都遵循 FIFO 先入先出原则。但
是这个特性存在一些问题（比如栈空间的内存释放受 FIFO 的限制），并未得到广泛引用，而且在很多平台上没有
得到支持，可移植性很差，不建议使用。

建议使用标准库的 `malloc`/`free` 来完成变长数组跟 `alloc` 相同的功能。

## 字符串

字符串就是一个以 `\0` 即 NULL 字符结尾的 char 数组：

```c
char str[10] = "Hello"; // {'H', 'e', 'l', 'l', 'o', '\0'};
```

因为需要一个 `\0` 结尾，长度为 10 的 str 数组实际只能存 9 个 char 字符！

## 指针（C 中最复杂的概念）

首先，ANSI C 定义 `char *` 为通用的指针（淘汰掉了 `void *`），因为数据的最小读写单位通常为 byte 也就
是 C 的 char，使用 char 来表示任何通用数据是比较合适的。

### 指针的算术运算

1.  指针可以加减一个整数，并且此计算会自动考虑指针所指对象的长度，如 `p++` 代表移到指针所在内存的下
    一个对象（内存地址）上。
2.  指针之间可以做减法运算，这表示两指针之间的 offset（同样以指针所指对象的长度为基本单位）。
3.  指针上的其他运算都是非法的，不同类型的指针之间的运算也是非法的，因为这些计算得到的结果都没有任何
    实际意义（如指针之和、指针上的乘除法）。
4.  指针运算非常容易出错！一定要慎重使用！！

### 指针跟数组

指针跟数组实际上非常相似，差别非常小。

相似之处：

- `a[i]` 跟 `*(a + i)` 实际上完全等价，其指针形式就是 C 底层对数组索引的真实处理逻辑！
- `&a[i]` 跟 `a + i` 当然也完全等价，都是指向第 i 个元素的指针
- 在将数组作为函数形参时，实际被传递给函数的是数组首个元素的指针。
  - 因此形参定义中的 `char []` 跟 `char *` 是完全等价的。
  - 因此可以通过指针来达成将数组的一部分传递到函数中的目的，比如 `f(&a[2])` 或者 `f(a+2)`，都使函数
    接受到的数组从第 2 个元素开始。

区别：

- 指针是一个变量，因此对指针 `p` 而言，`p++` 或者 `p = p + 1` 语句是完全合法的。但是对数组 `a` 而言
  `a++` 或者 `a = a + 1` 是非法语句。
- 指针跟数组的初始化也有不同
  - `char amessage[] = "hello world";` 定义的是一个字符数组，它指向了一块内存空间，空间中存放的值是
    可变的。
  - `char *pmessage =  "hello world";` 定义的是一个字符串指针，它指向的是一个**字符串常量**！
    - C 语言未定义对这个字符串常量做修改的结果！因此不要尝试这么干。

### 多维数组与嵌套指针

多维数组的缺点在于，它的子数组长度必须固定，或者说它必须是一个规整的 N 维矩阵！比如：

```c
// 平年与闰年，每个月的天数
// 第 0 个元素使用 0 作为占位符，使月份的索引从 1 开始
// 这个数组的维度是固定的 2 乘 13
char daytab[][] = {
   {0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31},
   {0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31}
};
```

如果一个函数需要接收一个二维数组作为参数，那它的形参必须声明其内部数组的长度！这是数组固有的缺陷：

```c
// 形参中的 13 不可省略！
int f(int daytab[][13]) {
   // do something
}
```

那如果要用不规整的多维数组呢？可以用数组指针：

```c
/* month_name:  return name of n-th month */
char *month_name(int n){
   // static 局部变量，一个私有的、永久性的存储，只会被初始化一次，所以足够高效。
   // name 是一个存放 char* 指针的数组，这样做的好处是内部的 char* 字符串（数组）长度可以不一致！
   static char *name[] = {
      "Illegal month",
      "January", "February", "March",
      "April", "May", "June",
      "July", "August", "September",
      "October", "November", "December",
   };

   return (n < 1 || n > 12) ? name[0] : name[n];
}
```

### 函数指针

函数指针通常用于将函数作为参数传递给其他函数，最典型的应用是在排序算法，用于传递元素之间的比较函数。

```c
qsort(
   (void**) array,  // array pointer
   0, // start
   end, // end

   // 将函数转换为函数指针传入到 qsort
   (int (*)(void*,void*))(numeric ? numcmp : strcmp),  // compare function pointer
);
```

那如何使用函数指针呢？看下面：

```c
// 跟普通指针一样，先用 * 取出它所指向的函数，然后再调用此函数即可
(*cmp)(a, b)
```

### C 指针各种复杂的声明语法

在涉及到指针的时候，各种变量的声明语法会变得复杂，难以直观理解。虽然实际工程中很少会见到这些复杂的用
法，但是还是有必要搞清楚它们的具体含义。

介绍如下：

```c
int *f();       // f: 一个返回 int* 类型的函数
int (*pf)();    // pf: 一个函数指针，指向一个返回 int，并且无调用参数的函数

char **argv;   // argv: （几乎等同于 char *argv[]）一个指针，指向 char* （字符串）

int (*daytab)[13] // daytab: 一个指针，指向 int[13] 类型的数组
int *daytab[13]   // daytab: 一个有 13 个元素的数组，数组中的每个元素为 int* 类型

// 这...疯了疯了
char (*(*x())[])()  /*
   这个有点复杂，从里往外一层层地剖析，并使用 it 来代表内层的定义：
      首先，`*x()` 表明 x 是一个函数，返回的是一个指针
      然后，外面一层是 `(*it)[]`，表明 it 是一个指向数组的指针
      而最外面是 `char (*it)()`，这就是数组每个元素的类型
   所以总结下就是，表明 x 是一个函数，返回的是一个指向数组的指针，数组中元素的类型为 `char (*it)()`
*/

char (*(*x[3])())[5] /*
   同样很复杂，从里往外一层层地剖析，并使用 it 来代表内层的定义：
      首先，`*x[3]` 表明 x 是一个有 3 个元素的数组，数组的元素是指针
      然后，外面一层是 `(it)()`，表明 it 是一个无参函数，返回值类型不确定
      而最外面是 `char (*it)[5]`，表明 it 是一个指针，指向一个 `char[5]` 类型的数组
   所以总结下就是，x 是一个有三个元素的数组，数组的元素是一个无参函数的指针，这个函数的返回值是 `char (*it)[5]`，即指向 `char[5]` 数组的指针
*/
```

### sizeof

sizeof 有两种是一个编译期运算符，其结果在编译期即可确定。有两种使用方式：

```c
// 查看一个 object 的 size
sizeof object

// 查看一个类型的 size
sizeof(type_name)
```

其返回值是一个 size_t 类型，准确的说是一个无符号整数，表示的是以 bytes 为单位的 size.

### typedef

typedef 可用于给类型取别名，主要功能为：

- 使代码更易于理解
- 别名类型与其他类型之间不可直接进行算术运算！这降低了代码出错的概率

常见用法之一是在定义数据结构时，使用 typedef 来赋予结构体新的名称：

```c
struct tnode { /* the tree node: */
   char *word;
   int count;
   struct tnode *left;
   struct tnode *right;  /* right child */
   /* points to the text */
   /* number of occurrences */
   /* left child */
};

// 定义两个新类型 Treeptr 跟 Treenode
typedef struct tnode *Treeptr;
typedef struct tnode Treenode;

// 使用定义好的新类型
Treeptr talloc(void)
   {
       return (Treeptr) malloc(sizeof(Treenode));
}
```

### Union

可以将 Union 看成一种将存储空间利用率极高的特殊结构体。

它的实际做法是，Union 中所有的变量都共享同一块存储空间，union 不同的成员变量其实只是在以不同的方式来
操作这块存储空间的数据。

```c
// 定义一个 union
union u_tag {
   int ival;
   float fval;
   char *sval;
} u;

// 访问一个 union，跟结构体的语法完全类似
union-name.member
union-pointer->member  // union 指针的成员访问语法
```

#### Bit-fields

为了更极致地节约存储空间，可以使用 bit 位来存储一些极小的数据。

我们可以通过 `enum { KEYWORD = 01, EXTERNAL = 02, STATIC = 04 };` 或者 `#define` 宏来达成类似的效
果，可以自己使用各种位操作运算来提取相关位的信息，但是 C 语言提供了更简单的方法：

```c
// 定义了一个包含三个 bit fields 的 struct
struct {
   unsigned int is_keyword : 1;
   unsigned int is_extern  : 1;
   unsigned int is_static  : 1;
} flags;
```

这种效率极高的结构，最常被用在各种网络数据包（IP 包、TCP/UDP 包、HTTP2 包）的编解码、二进制数据
（protobuf/mp3/mid/wav）的编解码中，这也是无符号整数的最大用武之地。

## 问题

### 浮点数在内存中是如何存储的？

将一个浮点数强制转换为整数类型，然后再用 16 进制打印出其内容，就能得到其存储表示：

```c
#include<stdio.h>

int main() {
    float a = 3.14;
    printf("float: %f\n", a);
    // &a 取指针，再将指针强转为 (int *) 类型，再取出指针所指向的值（int）
    printf("exact: %x\n", *(int *)&a);

    return 0;
}
```
