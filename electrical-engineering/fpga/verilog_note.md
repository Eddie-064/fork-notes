# verilog 学习笔记

我为了快速上手，只学了些简单的门电路基础知识就直接开始上手 verilog 了，一番研究发现最好的入门教程与
练习站点是： https://hdlbits.01xz.net/

这个教程对新手很友好，懂一点简单的门电路就能上手，而且有很多练习题，可以帮助你实践。

## 编写与烧录流程

1. 简单，直接写 verilog 代码
1. 综合（Synthesis）：把 verilog 代码转换成逻辑等式（并优化它们），一般生成一个 .json 文件。
1. 设置物理约束：就是把你的 verilog 代码的输入输出映射到 FPGA 的物理资源上，高云 IDE 会生成一个 .cst
   文件。
1. 布局（Placement）：就是把逻辑等式映射到 FPGA 的物理资源上（LUT 跟触发器）
1. 布线（Route）：找到并应用（我们用到的）所有物理资源之间的最佳连接方式。

最后使用 openfpgaloader 将生成的 .fs 文件烧录到 FPGA 上。

## 语法

verilog 可采用 3 种不同的方式进行设计建模：

1. 数据流描述——使用连续赋值语句建模
   1. 数据流描述是一种连续的描述方式，它描述的是电路本身的数据流动过程
1. 行为级描述——使用过程化结构建模
   1. 这种写法类似于 C 语言
1. 结构化方式——使用门和模块例化语句描述

### 数据流描述

verilog 的代码默认使用数据流描述，也就是连续赋值语句，这种语句的特点是：当输入信号发生变化时，输出信
号会立即发生变化。

```verilog
module and_gate(
    input a,
    input b,
    output y
);
    assign y = a & b;
endmodule
```

数据流描述使用了 `assign` 关键字进行连续赋值，使用 `wire` 数据类型连接代码描述的不同电路元件。

它跟普通代码有这几个特点：

1. 代码结构没有顺序，也就是说，你可以把 `assign y = a & b;` 放在任何地方，都不会影响最终的结果。
2. 代码是并行执行的，因为电路本身的特性就是这样的。
3. 代码是连续执行的，也就是说，当输入信号发生变化时，输出信号会立即发生变化。不需要等待什么时钟信
   号。

### 行为级描述

行为级描述有这几个关键字：

1. `always`: always 语句会在其条件满足时被重复执行，其条件可以是时间，也可以是信号。
2. `initial`: initial 语句从 0 时刻开始执行，只执行一次，多个 initial 块之间是相互独立的。
3. `generate`: generate 语句用于生成多个实例，你可以使用 generate 语句来生成 100 个实例。

#### 1. always 语句

`always` 关键字之后的代码块就是行为级描述，其内部的语法跟 C 语言类似，跟上面的数据流描述的代码就完全
不同了。

always 既可用于定义组合逻辑，也可用于定义时序逻辑。

1. 组合逻辑: `always @(*)`
   1. 组合逻辑的输出与时间无关，所以直接使用 `always @(*)` 即可。
1. 时序逻辑: `always @(posedge clk)`
   1. 时序逻辑的输出与时间有关，所以需要使用时钟信号来触发，所以使用类似 `always @(posedge clk)` 的
      语法来定义时序逻辑。
   1. posedge 表示上升沿，negedge 表示下降沿。

如下两个语句的功能是完全一致的：

```verilog
assign out1 = a & b | c ^ d;
always @(*) out2 = a & b | c ^ d;
```

一些注意项：

1. always 代码块中被赋值的变量必须是 `reg` 类型。
   1. 这区别于数据流描述中的 `wire` 类型。
1. always 代码块中的代码不能使用 `assign` 关键字。
1. 赋值的方法有几种：
   1. `assign out = a & b | c ^ d;`: 连续赋值，只能在数据流描述中使用。
   1. `out = a & b | c ^ d;`: 阻塞赋值，只能在 `always` 等行为级描述的代码块中使用，而且必须是组合逻
      辑。
   1. `out <= a & b | c ^ d;`: 非阻塞赋值，同样只能在 `always` 等行为级描述的代码块中使用，而且必须
      是时序逻辑。

时序逻辑的代码生成出的电路，其输出信号的变化是跟时钟信号有关的，也就是说，当时钟信号发生变化时，输出
信号才会发生变化。而组合逻辑，其输出信号的变化不存在这样跟时序相关的延迟，也就是说，当输入信号发生变
化时，输出信号会立即发生变化。

> 上面说的是理想情况，实际电路中组合逻辑的信号传播也是有延迟的，所以高频电路中，还需要考虑总线导线的
> 长度，长度不一致会导致信号到达时间不一致，从而导致问题。

#### 2. initial 语句

TODO

#### 3. generate 语句

可以使用在 generate 语句中的类型主要有：

- module（模块）
- UDP（用户自定义原语）
- 门级原语
- 连续赋值语句
- initial或always语句

比如这里使用 generate 语句生成了 3 个 bcdadd 实例：

```verilog
module top_module (
    input [15:0] a, b,
    input cin,
    output cout,
    output [15:0] sum );

    wire [3:0] c;

    // 第一个全加器实例
    bcd_fadd b1(a[3:0], b[3:0], cin, c[0], sum[3:0]);
    // 定义 i 作为 generate 中的循环变量
    genvar i;
        generate
            // generate 循环语句，该语句块必须使用 begin end 定义，并带有唯一的名字（标签）
            for(i=1; i < 4; i += 1) begin: bcdadd
                    //实例化 3 次全加器
                    bcd_fadd inst2_fadd(
                        a[i * 4 + 3 -:4], b[i * 4 + 3 -:4], c[i-1],
                        c[i], sum[i * 4 + 3 -: 4]
                    );
                end
        endgenerate
    assign cout = c[3];
endmodule
```

### 避免编写出锁存器（latches）

锁存器是一种时序逻辑，其输出信号的变化跟时钟信号有关，但是其输入信号的变化跟时钟信号无关，也就是说，
当时钟信号发生变化时，输出信号才会发生变化，但是当输入信号发生变化时，输出信号不会发生变化。

当你编写代码时，你必须首先从电路的角度去思考问题：

1. 我想要这个逻辑门
1. 我想要一堆组合逻辑电路，它有这些输入，产生这些输出
1. 我想要一堆组合逻辑电路外加一组触发器（flip-flops）

你不应该从代码的角度去思考问题，因为看起来符合你想象的代码，不一定会生成你想要的电路（组合逻辑 + 触
发器）。其主要原因通常都是：「**你代码中存在未定义行为，比如 if 语句少了个 else 声明**」verilog 的默
认行为是：「**当你的代码中存在未定义行为时，它不会修改系统当前的输出状态**」。

而不修改状态实际就是需要继承上一次的状态，这就会导致你的代码生成的电路变成时序电路，并且使用了锁存器
这个电路结构（`inferring latch(es)`）。

如果你想生成组合逻辑电路，那么你的代码中就不能存在未定义行为，也就是说，**你的代码中的任何分支都必须
为所有的输入输出赋值，否则就会生成锁存器**。
